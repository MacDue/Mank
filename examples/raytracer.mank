# Based on: https://www.scratchapixel.com/code.php?id=3&origin=/lessons/3d-basic-rendering/introduction-to-ray-tracing
# Made nice and manky!

fun trace: Vec3f (
  ray_origin: Vec3f,
  ray_dir: Vec3f,
  spheres: ref Sphere[6], # hardcode for now
  depth: i32
) {
  bind (INF, MAX_RAY_DEPTH) = (10000000000.0, 10);
  t_near := INF;
  hit_sphere_idx := -1;
  for s_idx in 0 .. spheres.length {
    bind (hit, t0, t1) = sphere_intersect(spheres[s_idx], ray_origin, ray_dir);
    if hit {
      if t0 < 0. { t0 = t1; }
      if t0 < t_near {
        t_near = t0;
        hit_sphere_idx = s_idx;
      }
    }
  }

  if hit_sphere_idx < 0 {
    return vec3f_from_f64(2.); # sky needs to be a very bright white
  }
  hit_colour := new_vec3f();

  hit_sphere := ref spheres[hit_sphere_idx];
  hit_point := vec3_add(ray_origin, vec3_scalar_mult(ray_dir, t_near)); # walk down ray
  hit_normal := vec3_sub(hit_point, hit_sphere.centre);
  vec3f_normalize(hit_normal);

  if hit_sphere_idx == 2 {
    # Hack to add a texture!
    hit_sphere.colour = get_earth_texel(hit_normal);
    hit_sphere.emission_colour = hit_sphere.colour;
  }

  # used to help with normals (just move them a tiny bit so their not on the surface)
  bias := 1./10000.;

  inside_sphere := false;
  if vec3_dot(ray_dir, hit_normal) > 0. {
    # view dir and normal not in opposite directions (inside)
    hit_normal = vec3_minus(hit_normal);
    inside_sphere = true;
  }

  if (hit_sphere.transparency > 0. || hit_sphere.reflection > 0.) && depth < MAX_RAY_DEPTH {
    facing_ratio := -vec3_dot(ray_dir, hit_normal);
    fresnele := mix(pow(1. - facing_ratio, 3.), 1., 0.1);

    reflect_dir := vec3_sub(ray_dir, vec3_scalar_mult(hit_normal, 2. * vec3_dot(ray_dir, hit_normal)));
    vec3f_normalize(reflect_dir);
    reflection := trace(vec3_add(hit_point, vec3_scalar_mult(hit_normal, bias)), reflect_dir, spheres, depth + 1);

    # Now refraction/transmission
    refraction := new_vec3f();
    if hit_sphere.transparency > 0. {
      # Spooky maths...
      ior := 1.1;
      eta := if inside_sphere { ior } else { 1. / ior };
      cosi := -vec3_dot(hit_normal, ray_dir);
      k := 1. - eta * eta * (1. - cosi * cosi);
      refract_dir := vec3_add(
        vec3_scalar_mult(ray_dir, eta),
        vec3_scalar_mult(hit_normal, eta * cosi - sqrt(k)));
      vec3f_normalize(reflect_dir);
      refraction = trace(vec3_sub(hit_point, vec3_scalar_mult(hit_normal, bias)), refract_dir, spheres, depth + 1);
    }

    hit_colour = vec3_mult(
      vec3_add(
        vec3_scalar_mult(reflection, fresnele),
        vec3_scalar_mult(refraction, (1. - fresnele) * hit_sphere.transparency)),
      hit_sphere.colour);
  } else {
    # Boring faked diffuse light
    path_blocked := \light_idx, light_dir: Vec3f -> {
      for s_idx in 0 .. spheres.length {
        if s_idx == light_idx { continue; }
        bind (hit, _, __) = sphere_intersect(spheres[s_idx],
          vec3_add(hit_point, vec3_scalar_mult(hit_normal, bias)), light_dir);
        if hit { return true; }
      }
      false
    }

    max := \a,b -> { if a > b { a } else { b } }

    for s_idx in 0 .. spheres.length {
      emission := ref spheres[s_idx].emission_colour;
      if vec3_length(emission) > 0. {
        # Light source
        light_dir := vec3_sub(spheres[s_idx].centre, hit_point);
        vec3f_normalize(light_dir);

        if path_blocked(s_idx, light_dir) {
          continue;
        }

        # attenuation & emission
        hit_colour = vec3_add(hit_colour, vec3_mult(hit_sphere.colour,
          vec3_scalar_mult(emission, max(0., vec3_dot(hit_normal, light_dir)))));
      }
    }
  }

  vec3_add(hit_colour, hit_sphere.emission_colour)
}

proc ray_trace(image_width: i32, image_height: i32, spheres: ref Sphere[6]) {
  # image pixel array not needed... if we just print pixels on the fly
  # (vectors still very needed!)
  # TODO: Vectors! Can only handle tiny images with stack memory :(
  # image := [=[=new_vec3f();60];60];

  M_PI := 3.141592653589793;
  bind (fov, aspect) = (30., image_width as f64 / image_height as f64);

  inverse_width := 1. / image_width as f64;
  inverse_height := 1. / image_height as f64;
  angle := tan(M_PI * 0.5 * fov / 180.);

  float_to_char := \f -> {
    (if f >= 1. {
      1.
    } else {
      f
    } * 255.) as char
  };

  output_rgb := \rgb: Vec3f -> {
    bind {.x/r, .y/g, .z/b} = rgb;
    putchar(float_to_char(r));
    putchar(float_to_char(g));
    putchar(float_to_char(b));
  }

  # Make .ppm image
  println!("P6\n{width} {height}\n255",
    int_to_string(image_width), int_to_string(image_height));
  for y in 0 .. image_height {
    for x in 0 .. image_width {
      xx := (2. * ((x as f64 + 0.5) * inverse_width) - 1.) * angle * aspect;
      yy := (1. - 2. * ((y as f64 + 0.5) * inverse_height)) * angle;
      ray_dir := vec3f_from_xyz(xx, yy, -1.);
      vec3f_normalize(ray_dir);
      output_rgb(trace(new_vec3f(), ray_dir, spheres, 0));
    }
  }
}

proc mank_main {
  spheres := [
    # Middle sphere
    make_sphere(
      vec3f_from_xyz(0., 0., -20.), 4., vec3f_from_xyz(1., 0.32, 0.36), 1., 0.5, new_vec3f()),
    # Right sphere
    make_sphere(
      vec3f_from_xyz(5., -1., -15.), 2., vec3f_from_xyz(0.90, 0.76, 0.46), 1., 0., new_vec3f()),
    # Earth
    make_sphere(
      vec3f_from_xyz(6., 3., -20.), 2.4, new_vec3f(), 0., 0., new_vec3f()),
    # Left sphere
    make_sphere(
      vec3f_from_xyz(-5.5, 0., -15.), 3., vec3f_from_xyz(0.67, 0.84, 0.90), 1., 0., new_vec3f()),
    # Ground
    make_sphere(
      vec3f_from_xyz(0., -10004., -20.), 10000., vec3f_from_xyz(0.5,0.25,0.155), 0., 0., new_vec3f()),
    # Light (behind view plane)
    make_sphere(
      vec3f_from_xyz(0., 20., -30.), 3., new_vec3f(), 0.0, 0.0, vec3f_from_f64(3.))
  ];

  bind (WIDTH, HEIGHT) = (1920, 1080); # fine for my PC -- adjust as needed
  eprintln("Tracing...");
  ray_trace(WIDTH, HEIGHT, spheres);
  eprintln("Done!");
}

# Alpha mixing

fun mix: f64 (a: f64, b: f64, mix: f64) {
  b * mix + a * (1. - mix)
}

# Sphere

pod Sphere {
  # World
  centre: Vec3f,
  radius: f64,
  radius_squared: f64,
  # Props
  transparency: f64,
  reflection: f64,
  # Colours
  colour: Vec3f,
  emission_colour: Vec3f
}

fun make_sphere: Sphere (
  centre: Vec3f, radius: f64, colour: Vec3f,
  reflection: f64, transparency: f64, emission_colour: Vec3f
) {
  Sphere {
    .centre = centre,
    .radius = radius,
    .radius_squared = radius * radius,
    .colour = colour,
    .emission_colour = emission_colour,
    .transparency = transparency,
    .reflection = reflection
  }
}

fun sphere_intersect: (bool, f64, f64) (
  sphere: ref Sphere,
  ray_origin: Vec3f,
  ray_dir: Vec3f
) {
  # Some maths (copied -- including meaningless var names :()
  MISS := (false, -1., -1.);
  l := vec3_sub(sphere.centre, ray_origin);
  tca := vec3_dot(l, ray_dir);
  if (tca < 0.) { return MISS; }
  d2 := vec3_dot(l,l) - tca * tca;
  if (d2 > sphere.radius_squared) { return MISS; }
  thc := sqrt(sphere.radius_squared - d2);
  (true, tca - thc, tca + thc)
}

# Vector

pod Vec3f {
  x: f64, y: f64, z: f64
}

fun new_vec3f: Vec3f {
  Vec3f { .x = 0., .y = 0., .z = 0. }
}

fun vec3f_from_f64: Vec3f (f: f64) {
  Vec3f { .x = f, .y = f, .z = f}
}

fun vec3f_from_xyz: Vec3f (x: f64, y: f64, z: f64) {
  Vec3f { .x = x, .y = y, .z = z}
}

fun vec3_length_squared: f64 (vec: ref Vec3f) {
  bind {.x, .y, .z} = vec;
  x * x + y * y + z * z
}

fun vec3_length: f64 (vec: ref Vec3f) {
  sqrt(vec3_length_squared(vec))
}

proc vec3f_normalize(vec: ref Vec3f) {
  l2 := vec3_length_squared(vec);
  if l2 > 0. {
    scale := 1. / sqrt(l2);
    vec.x *= scale;
    vec.y *= scale;
    vec.z *= scale;
  }
}

fun vec3_scalar_mult: Vec3f (vec: Vec3f, scalar: f64) {
  vec.x *= scalar;
  vec.y *= scalar;
  vec.z *= scalar;
  vec
}

fun vec3_mult: Vec3f (a: Vec3f, b: Vec3f) {
  vec3f_from_xyz(a.x * b.x, a.y * b.y, a.z * b.z)
}

fun vec3_dot: f64 (a: Vec3f, b: Vec3f) {
  a.x * b.x + a.y * b.y + a.z * b.z
}

fun vec3_sub: Vec3f (a: Vec3f, b: Vec3f) {
  vec3f_from_xyz(a.x - b.x, a.y - b.y, a.z - b.z)
}

fun vec3_add: Vec3f (a: Vec3f, b: Vec3f) {
  vec3f_from_xyz(a.x + b.x, a.y + b.y, a.z + b.z)
}

fun vec3_minus: Vec3f (vec: Vec3f) {
  vec3f_from_xyz(-vec.x, -vec.y, -vec.z)
}

# Mank logo

fun sample_mank_logo: i32 (x: i32, y: i32) {
  # TODO: make better
  logo := [
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 251, 187, 154,
    223, 249, 53, 170, 191, 250, 174, 178, 127, 251, 160,
    186, 127, 251, 174, 186, 191, 251, 174, 186, 223, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255];

  px := y * 32 + x;
  cell := px / 8;
  (logo[cell] >> (7 - px % 8)) & 1
}

fun get_uv: (f64, f64) (normal: Vec3f) {
  PI := 3.14159;
  (
    0.5 + atan2(normal.z, normal.x) / (2. * PI),
    0.5 - asin(normal.y) / PI
  )
}

fun get_mank_texel: Vec3f (normal: Vec3f) {
  bind (u, v) = get_uv(normal);
  s := if sample_mank_logo((u * 32.) as i32, (v * 32.) as i32) == 1 { 1. } else { 0.4 }
  vec3f_from_f64(s)
}

# Earth

fun sample_earth_texture: Vec3f (x: i32, y: i32) {
  earth := [
    730449, 533072, 335176, 335177, 928088, 2310255, 2245495, 4020610, 7175577,
    6256024, 7966124, 9214385, 10529210, 10463157, 3360876, 466500, 794953,
    2308448, 1651552, 863324, 1192545, 1783911, 1258340, 798047, 2111327,
    2899295, 1058125, 400452, 862035, 1259630, 864098, 600154, 1851245, 2043969,
    1909805, 1648442, 2636625, 6582395, 6846860, 8425377, 7964822, 5202813, 4480647,
    14212833, 16777215, 11385027, 2573420, 664915, 861779, 2441317, 2177873, 1653863,
    2048104, 3098463, 2767432, 2634548, 4146488, 5132090, 3554868, 2634551, 3226687,
    3291951, 2373700, 2572119, 1983089, 2438196, 2699828, 3423292, 2830359, 1712392,
    2566159, 3226173, 2311021, 3883842, 1059146, 3820396, 4149621, 7760, 1520994,
    1588073, 2112609, 2043952, 1517077, 1713415, 1845001, 1647107, 2304008, 2040836,
    1516294, 1384707, 1911046, 2239496, 2765333, 3293252, 2701620, 2370604, 332073,
    265765, 2338, 334146, 1780538, 3553049, 4014113, 1582347, 1450514, 1648399,
    1979716, 534613, 2858, 793921, 399419, 1979980, 2767153, 2897441, 3029533,
    2568989, 4277036, 6314558, 6116149, 4605224, 4933677, 4867883, 4933677, 2765583,
    1649438, 1193834, 596791, 2336, 270, 66062, 197907, 67099, 1055282, 7167555,
    6970171, 3357462, 2240526, 1189173, 266797, 396834, 595508, 860745, 796, 3618617,
    5591888, 2504782, 2504262, 6249036, 6512721, 9798500, 8285771, 8747102, 9403742,
    7759687, 5460013, 2637119, 1388362, 462623, 273, 198167, 199198, 198939, 132373,
    198680, 2595, 2634056, 5986107, 2569787, 1586000, 331558, 6, 264733, 463664,
    132374, 2567491, 11243381, 12951155, 11309172, 10521977, 9995118, 11310194,
    7959146, 7762265, 6512697, 4474919, 2042635, 2570268, 1585748, 464436, 198940,
    198167, 132374, 198940, 198682, 132115, 66580, 199198, 70454, 991545, 1583665,
    1256520, 1188928, 529710, 199461, 395802, 533, 4343629, 10587993, 10324059,
    11310183, 11637600, 6973267, 9141873, 2239818, 1714239, 3686457, 1387848,
    2768169, 1454164, 398119, 66838, 332073, 132115, 198682, 132116, 199198,
    132888, 198942, 199714, 397869, 465214, 597316, 1255752, 2174489, 1912096,
    925490, 135217, 331819, 135204, 925206, 1977895, 2241298, 1912845, 5393705,
    4274235, 1057, 728125, 859195, 597571, 2179424, 1585742, 925232, 397351, 529972,
    397871, 265508, 198940, 198940, 133147, 265767, 199715, 398129, 596539, 333884,
    1450551, 1845770, 1319939, 3094041, 3092530, 133405, 397356, 199978, 134440, 2173985,
    3289620, 4668724, 69420, 596024, 464694, 132631, 198681, 1056817, 1651013, 599370,
    1126478, 860987, 795726, 464694, 265507, 198682, 332075, 464180, 464179, 597058,
    464180, 331562, 265511, 3290158, 3750173, 5522723, 2961198, 274, 463663, 397608,
    67355, 5458242, 6507818, 3421753, 1647157, 530747, 464179, 198167, 264475, 273,
    924218, 4670540, 5984324, 3161426, 533067, 728897, 132115, 132116, 199199, 332076,
    464696, 663109, 531006, 661817, 3631, 3288889, 5524004, 2831669, 465986, 199199,
    397870, 463146, 2083, 5130573, 7428670, 1122621, 1054766, 133148, 463922, 398129,
    463660, 1566, 3157813, 7162413, 8871226, 7033650, 927308, 796501, 264991, 132115,
    66320, 132116, 199457, 531006, 531006, 596024, 70713, 3421491, 4080704, 266537,
    531, 331561, 597058, 464437, 66581, 396834, 857903, 266542, 531780, 264733, 265767,
    663109, 662592, 266024, 462881, 528674, 1318189, 2304814, 265250, 1322842, 198423, 132888,
    265764, 331043, 463663, 729160, 595766, 331042, 398128, 3950420, 1455976, 332851, 463660,
    265765, 596024, 860489, 727867, 463147, 198941, 595765, 465212, 134179, 1125208, 597315,
    267060, 202041, 200751, 2337, 3371, 202298, 265249, 1387857, 331819, 464954, 531008,
    135214, 1566, 792, 275, 269, 275, 266538, 1845054, 462886, 463662, 199971, 273, 537,
    532, 271, 268, 267, 395802, 461595, 2852, 398124, 988714, 1648196, 990522, 924213,
    1187902, 597057, 5693, 135730, 597315, 398645, 661044, 2108231, 3687520, 3359329,
    3951206, 5858429, 5202304, 10068140, 9476002, 268087, 596021, 792368, 4803929, 8421510,
    9145747, 9342870, 9408920, 10658984, 13291217, 13685718, 11185327, 12369600, 14541028,
    14870511, 14278376, 14212840, 14541546, 13028825, 10464192, 4413823];

  px := y * 32 + x;
  s := earth[px];
  b := s & 255;
  g := (s >> 8) & 255;
  r := (s >> 16) & 255;

  vec3f_from_xyz(r as f64 / 255.,  g as f64 / 255., b as f64 / 255.)
}

fun get_earth_texel: Vec3f (normal: Vec3f) {
  bind (u, v) = get_uv(normal);
  sample_earth_texture(32 - (u * 32.) as i32, (v * 15.) as i32)
}
